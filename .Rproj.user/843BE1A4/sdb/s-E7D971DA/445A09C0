{
    "collab_server" : "",
    "contents" : "##Tip: Create a project to work on the data analysis and this will avoid the issue of setting a working directory. Within a project you can have an R script and create an RMD. \n\n##Lecture 1: 2017/1/18\n## Two ways to assign information to an object: == or >-\ntmp=24/37\ntmp\ntypeof(tmp) #'double' means this is a real number with decimals. You can also have integers (64), character ('type'), and factors. 'double' means double precision--it explains how this data is stored in the computer\ntmp2<-\"ThisIsText\" #put into a new variable called tmp2\ntypeof(tmp2) #this is character\ntmp!=tmp2 # != means not equal. This is asking True/False: is tmp not equal to tmp2. [TRUE]\n#capitalization matters in R. \n\n##Comparing things\n\n\nsetwd(\"/Users/MadelineWeeks1/Documents/Research/R/ECI289RDavis/RawData\")\nSEdat = read.csv(\"StudentSocioEconData.csv\", sep=\",\", header=TRUE) \nnrow(SEdat)\nncol(tripdat)\ndim(SEdat)\ncolnames(SEdat) #The column X: it thinks there is something there. There is a naming problem with the columns\nhead(SEdat) #this displays the first six rows of all the columns, useful for seeing how the data came in. \nstr(SEdat) #This gives the structure of the data. Data frame. int=integer. logi=logical (True/False)\n#R can store things in different ways: vector, matrix (only numbers), or data frame (mix of numbers and text, i.e. characters). She recommends data frame because does everything a matrix will do and is more flexible. Data frame allows you to have non-numeric, factors like Yes/No. \nSEdat[,1] #[row, column] This is asking for the first column of the data frame. Always use brackets when referring to something in the R dataframe. It is a dataframe because it has both character and numeric. \nSEdat[1,] #To look at first row. \nSEdat[1,2] #first row, second column \nSEdat[1,1:2] #First row, first and second column \n#click \"escape\" then correct\n#In consulte, use Up arrow and can see the last previous command. \nSEdat[1:10,] #to show the first 10 rows (all columns)\n\n#Lets suppose that you want to add a column that is 1 if <= 3 classes; 0 otherwise\ntmp=cbind(SEdat, NumCls=0) #bind the data frame to something called NumCls=0\nhead(tmp) #can see that the column has been added. \n#suppose you want to say it is \nstr(tmp) #the $ tells you the variable. \ntmp$NumCls[tmp$No..of.Classes>3]=1 #use $. this is a vector. Everywhere temp number is classes >3, give it a 1. Rename NumCls from 0 to 1.\ntmp$NumCls[tmp$No..of.Classes>3] = 1\ntable(tmp$NumCls) #tells you there are 0 1s and 18 of 32. \n\n##Lecture 2 2017-1-23\n#Use dimension (dim) to check your data came in correctly. \nsetwd(\"/Users/MadelineWeeks1/Documents/Research/R/ECI289RDavis/RawData\")\nrawDat = read.csv(\"HW2-RSurvey2017RAW.csv\", sep=\",\", header=TRUE) \ncolnames(rawDat)\ncolnames=c(\"year\",\"prog\",\"level\",\"knowR\",\"nerves\")\nrawDat[1:10,1] #code for rows 1-10 of 'year'\nrawDat[,\"level\"]==\"PhD\" #What in the level variable is equal to a PhD? The answer will be in the form of T/F.\nrawDat[rawDat[,\"level\"],]#If the level variable is equal to PhD, want everything in that dataset (for the column). This will give a subset of all the data where level is equal to PhD.\nrawDat[rawDat[,\"level\"],\"year\"] #Same as above, but only want year.\nrawDat$level==\"PhD\" #another way to write rawDat[,\"level\"]==\"PhD\". Can use the $ b/c it is a dataframe. \n\n#New topic: Factors. \n#Study: Logical vs. categorical. what are factors?\n#Factors are categories.Every time you bring in a factor, R assigns it a unqiue number for each level. \ntable(rawDat$nerves) #Stores each unique answer as a number. Nerves is a factor with 5 levels. \n#can ask R to show you what the levels are:\nlevels(rawDat$nerves) #Level 2=Nervous? It assigns the levels based on the order in which they come into R. BUT the issue is that those levels may not be based on our intuitive scales. When R assigns factors it doesn't care about order; only cares about unique numbers. \n#command 'factor' turns something into a factor to give it the desired levels. Remember, two unique parts to factors: the levels and the labels for the levels. \nrawDat$nerves=factor(rawDat$nerves, labels=c(\"Middle\",\"NotReally\",\"SortOf\",\"Super\",\"WhyNerves\")) #Levels works with the data. Labels works with what you call the data. 'c' command combines. Assign the same order. Replace [1] middle of the road with \"super.\" \n#Then check:\ntable(rawDat$nerves) #to see whether levels are in order. We haven't changed the data; have only changed lables; have only changed the way it prints out. When R sets labels, there is no order. When R sets levels, only based on the order in which they come in. \n#Levels do not drop naturally. Suppose you take out 'Why nerves'.\nrawDat[rawDat$nerves!=\"Why nerves\",] #Go through every row of the variable 'nerves' and if nerves is not equal to \"Why nerves\" we want it, for all the columns. \nlevels(rawDat) #still get 'Why nerves.' R does not drop Why nerves' naturally. So need to use command 'drop levels'\nonlyNerves=droplevels(onlyNerves)\n\n##New topic: Data Cleanup (for homework)\n#These functions are called 'regular expression.' These are tools that allow you to finding patterns in data, which is very useful for data cleanup. \ntable(rawDat$prog)\n#command 'grep' allows you to pull everything with \"Eng\" \n#command 'grepl' is a logical command, will output in the form T/F. Could table it ans say False is not engineer, true is engineer. Or could do a replacement to label engineer as 'not desireable'. Can use T/F to test for other things. \n#command 'sub'. Sub will take the first replacement.\nrawDat$prog[1:14] #take the first 14 rows. \nsub(\"-Env\",\"E\",rawDat$prog[1:14])#look for '-Env' and replace it with \"E\" Here, not assigning, so no damage has been done. \n#There is no undo command. Instead, could re-run code from the beginning. Be careful when assigning. \n#command 'gsub' is another way to replace; gsub will take all the replacement. For example if the object is \"Civil-Env Eng-Env\" gsub will get all the Env (for both Civil and Eng) whereas sub will only get the first \"Env'. If really sure about what you are replacing, can use gsub. Most of the time she just uses sub. Look up quantifiers and operators (don't have to know for this class, work for any programming language. See html online)\ngsub(\"A\",\"ZZZZ\",rawDat$prog[1:14])\n#command 'substr'/'substring': work about the same. \nsubstr(rawDat$prog[1:14], 1,2) #Gets the first and second character of each element. Using quantifiers and operators, can mix and match this. \n\n#Final topic for today: NA\n#NA means there is a missing value. It is a decision we make OR R can automatically assign if there is no value for that object. \ntmp=c(5,6,7,NA,0,10,99) #create a vector\nis.na(tmp) #To check whether there are NA in the vector 'temp.' will output logical T/F.\n#suppose 99 is also a non-response/missing value\ntmp[tmp==99]=NA\ntmp\n#now want a datastring without NA. Assign to a new variable.\ntmp1=na.omit(tmp)\ntmp1 #The first line is the new vector without NA, attr(,\"na.action\") tells you that tmp1 was produced by an na action; this allows you to go back and see where the object originated from. The second line are the index positions that became NA. \ntmp[1:4]\ntmp+1\nsum(tmp) #output=NA b/c can't add an NA. \ntmp[tmp==NA]\n\n\ninstall.packages(\"swirl\")\nlibrary(swirl)\nswirl()\n\ninstall.packages(\"devtools\")\n\n##Lecture 4: 2017-1-30\n#STudy this:\n#https://www.tutorialspoint.com/r/r_operators.htm\n#operators at the beginning of the html file\n\n##Create the data we'll use today\nSfacts = read.csv(\"county_facts.csv\", header= T, sep=\",\") #bring in the data\ntodayData1 = subset(Sfacts,state_abbreviation==\"AL\"|state_abbreviation==\"TN\"|state_abbreviation==\"KS\"|state_abbreviation==\"MI\"|state_abbreviation==\"MN\"|state_abbreviation==\"CA\",select=c(\"fips\",\"area_name\",\"state_abbreviation\",\"PST045214\",\"SEX255214\",\"HSD310213\",\"INC110213\")) #Creates a subset based on only certain rows and certain columns. Sfacts is the object you are subsetting. Bring in 6 states. | denotes \"or.\" select=c(...) means you are only selecting those columns. Formula: subset (X, row selection, column selection)\ncolnames(todayData1) = c(\"fips\",\"county\",\"state\",\"pop\",\"femaleP\",\"perhh\",\"medhhinc\") #Rename the columns. P means %. Could also define those variables at the top of the file. \ntodayData1$state = droplevels(todayData1$state) #Before doing this, would get levels of all 50 states. This is dropping all the extra levels.Only drops levels not being used in your dataset. For all my levels in state, drop all levels that I am not using. \nlevels(todayData1$state) #To check. See that you now only have levels of six states. \ntodayData1$county = droplevels(todayData1$county)\n\n#Another way to do subset. Do the “subset” a different way?\ntodayData2 = Sfacts[Sfacts$state_abbreviation %in% c(\"AL\",\"TN\",\"KS\",\"MI\",\"MN\",\"CA\"),names(Sfacts) %in% c(\"fips\",\"area_name\",\"state_abbreviation\",\"PST045214\",\"SEX255214\",\"HSD310213\",\"INC110213\")] #Formula for objects with brackets: \n#$stateabbreviation[row, column] most simple form. Let's break it apart:\n#This version implements the same thing as subset or []’s with lots of “|” (or’s). Let break it apart and look at what is happening. Break things up to understand how they work. First, the row selection,\ntmpData[tmpData$state_abbreviation %in% c(\"AL\",\"TN\",\"KS\",\"MI\",\"MN\",\"CA\"), 'column'] #'column' is a placeholder. #operator %in% can be used to subet rows. The %in% operator is used for subsetting rows when selecting on more than one value. We use the %in% notation when we want to subset on multiple values of y.  Literally: test each x for membership in y\n#%in% handles factors better than 'which'. She only uses which.max or which.min. \n#aggreg(cbind(A,B)) factors are the best and worst thing, what happened here is R has a hierarchy to data: characters, integers, factors, real. B was character data. A was integer data. By the way cbind is built, took the character (B) and turned it into an integer so that A and B could match. \n#Try a simple example to illustrate %in%:\nt1 = 10\nt2 = 14\nz = 11:20\n(t1 %in% z) #FALSE because 10 is not between 11 and 20. \n(t2 %in% z) #TRUE because 14 is between 11 and 20\n\n#COLUMN SIDE. Now let’s look at the column side,\nSfacts[‘row’,names(Sfacts) %in% c(“fips”,“area_name”,“state_abbreviation”,“PST045214”, “SEX255214”,“HSD310213”,“INC110213”)]] #'row' is a placeholder.\n#What’s happening here? Selecting for those specific columns c(\"fips,\" \"area_name\" etc)\nnames(Sfacts) #this gives us all the column names. In the above command, it says go to names and for every name yank it out as true. \n\n#Introduce a few more new functions: dropping a column, all, any, match, merge\n#1. Dropping a column\nstr(todayData2) #Note: state_abbre has 52 levels\ntodayData2$fips      = NULL #To drop the column fips\ntodayData2[,\"area_name\"]  = NULL #Drop the column 'area_name'\ntodayData2[,3]       = NULL #Drops the third column\n# Ways to remove 2 columns\ntodayData2 = todayData2[,-c(4:5)] #Drop columns 4 and 5. The '-' denotes drop within the row/column context. \ntodayData2 = subset(todayData2, select=-c(PST045214,HSD310213)) #Also drops the columns PST045214 and HSD310213\n(str(todayData2)) #only state_abbreviation remains. () on the way outside echoes immediately to the consule, so no need to do control enter. \n\n#Command ls: lists all the objects in your working space\nls() #now you can figure out what's there to get rid of an object\nrm(todayData2) #rm gets rid of an object\n\n#+ What does NULL mean? undefined; list with zero length What’s the difference between NA and NULL? NULL is undefined. NA could exist; it is a datapoint. NULL cannot exist. If you find a NULL, look at your spelling, punctuation; look at your code for an error. \n#2. all and any\nall(todayData1$state==\"AK\") #will look for any rows that are equal to AK. FALSE because there are no AK rows. \nany(todayData1$state==\"CA\") #TRUE b/c data in my vector that are CA. This is useful when trying to compare two datasets that don't match in rows. \n#3. match\nmatch(todayData1$state,Sfacts$state_abbreviation, -99)\n#todayDat$state is the vector I want to work on\n#Working with two different datasets. Are there any matches from todayDat1 that are in Sfacts? Check each row of state\n# set -99 if not found, picks row of 1st match\n#Gives the first occurrence of todayDat$state in the second data set Sfacts. If AL did not exist, it would set a 99. The first state in todayDat1 is AL--then go to the other dataset sfacts and say which row AL first appears in. The first occurrence for every AL in Sfacts is row 2. \n#Reason for using -99: Suppose #57 is Al, it would go to Sfact$state and doesn't find Al so it sets #57 to -99. Could be -99 or -3, or -Anything. Whenever you want to track missing values the culture is to use -9, -99, etc. to signal missing data. \nmatch(todayData1$county,Sfacts$area_name, -99)  # set -99 if not found\n#4. merge\n#Bring in the election data for the same states we are using\ntmpData = read.csv(\"US_County_Level_Presidential_Results_12-16.csv\", header= T, sep=\",\") #grab the other dataset\ntodayElect = subset(tmpData,state_abbr==\"AL\"|state_abbr==\"TN\"|state_abbr==\"KS\"|state_abbr==\"MI\"|state_abbr==\"MN\"|state_abbr==\"CA\", select=c(\"FIPS\",\"county_name\",\"state_abbr\",\"votes_dem_2016\", \"votes_gop_2016\")) #Subset on the 6 states. \ncolnames(todayElect) = c(\"fips\",\"county\",\"state\",\"demvote\",\"gopvote\") #Rename columns\ntodayElect$state = droplevels(todayData1$state) #now only carry 6 states, drop levels\ntodayElect$county = droplevels(todayData1$county) #Drop extra county names\n(str(todayElect)) #495 obs, both datasets have the same number of observations. Ready to merge them. \n\n#Merge it with the county data\n#call full data the two merged datasets. \nfulldata = merge(todayData1,todayElect) # by default matches on the columns that are the same. fips, county, and state are the columns that are the same. If zero match, it will return null. \nstr(fulldata) #So matched the three columns and added in the additional columns. \n\n#two other ways\n#fulldata = merge(todayData1,todayElect, by=\"fips\")  # I named this the same in both data. Will only match on one variable 'fips.' If you want to match on a single variable that is unique to every row, need to make sure that the two column names are the same. \n#fulldata = merge(todayData1,todayElect, by=c(\"state\",\"county\")) #will match on two variables \"state\" and \"county\"\n#can also play with merge sum. \n\n#Rest of the class: Pair Up. Select four states and tell me something about the population socio-economic and voting. \nnames(fulldata) #column names\nstr(fulldata)\nlevels(fulldata$state)\nfulldata2=fulldata[fulldata$state %in% c(\"AL\",\"CA\",\"KS\",\"MI\"),]\nfulldata2$state=droplevels(fulldata2$state) #drop levels\nlevels(fulldata2$state) #make sure ony 4 state levels. \nhead(fulldata2)\nnew_column=fulldata2$demvote/fulldata2$pop\nfulldata2=cbind(fulldata2, perdem=new_column)\nnew_column=fulldata2$gopvote/fulldata2$pop\nfulldata2=cbind(fulldata2, pergop=new_column)\n#Subset for states with female population>50%\nfulldata3=subset(fulldata2,fulldata2$femaleP>=50,)\n##another way:\nfulldata4=fulldata2[fulldata2$femaleP>=50, ]\n#and perdem>10%\nfulldata5=fulldata2[fulldata2$femaleP>=50 & fulldata2$perdem>=0.1,]\nfulldata5[fulldata5$state==\"CA\",]\n\n\n###CLASS 2-Lecture 2017-2-1\n##R MARKDOWN\ninstall.packages(\"rmarkdown\")\n#Workflow: 1) Write code in R script, 2) Clean up in R Markdown, 3) Send to someone else as an html file for feedback and replication. \n#RMD documents (for turning in final project). It is NOT R. RMD files are great for replication. We are trying to create a more standard approach to data anlysis. You can get really fancy with R Markdown, do templates for scientific publications. \n#YAML: warning, frustrating because really need to be accurate about formating. Stick with simple YAMLs. This is the YAML:\n---\n  title: \"R Notebook\"\noutput:\n  html_document:\n  highlight: tango\nhtml_notebook:\n  highlight: tango\n#CSS (style sheets) you can set style sheet parameters. \n# Table: | means you are about to start a table. \"nbsp\" means non-breaking space. Gives extra spaces to make the table look good without entering a new line (that is HTML). R Markdown language parses HTML (basic formatting). You might want to create a table at the beginning of your R Markdown to define all the variables. \n#{r} R chunk. This is where you write your code. Tip: Write everything in an R script, all commented, then in the final report put the clean code from R file into RMD file. Ex: {r data input, include=FALSE}, name the code chunk \"r data input,\" and include=FALSE means you run the code and you will not show the output.\n#<br> gives you vertical distance. Makes it easier to read. \n# + (tab, plus, 2 spaces) means that everything that follows is on an indentation. \n\n#Modeling: By the time you get to modeling, you should have so much information from your data exploration that you know what the model should include. \n\n###CLASS 3-Lecture 2017-2-6 (Missed this class, use Jen's notes)\n\n#Class 2017.2.8 GGPLOT\n\n",
    "created" : 1488382456157.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2865282016",
    "id" : "445A09C0",
    "lastKnownWriteTime" : 1487781390,
    "last_content_update" : 1487781390,
    "path" : "~/Documents/Research/R/ECI289RDavis/Lectures/2017_RWinterLectures.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}